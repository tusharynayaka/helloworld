<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Collaborative Meetup Planner (Simulated Isochrone)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root { --primary-color: #4f46e5; --secondary-color: #ec4899; }
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        .container-card { 
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.1); 
            max-width: 90%; 
            margin: 2rem auto; 
            background: linear-gradient(145deg, #ffffff, #f0f0f0); 
            border: 1px solid #e5e7eb; 
            transition: all 0.3s ease-in-out; 
        }
        @media (min-width: 640px) { .container-card { max-width: 700px; } }
        .submit-button { 
            transition: all 0.2s ease-in-out; 
            background-image: linear-gradient(to right top, var(--primary-color), #6366f1); 
        }
        .submit-button:hover { opacity: 0.9; transform: translateY(-1px); }
        .loading-spinner { 
            border: 4px solid rgba(255, 255, 255, 0.3); 
            border-top: 4px solid #ffffff; 
            border-radius: 50%; 
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .travel-table th, .travel-table td {
            padding: 8px;
            text-align: left;
        }
        .travel-table th {
            font-weight: 600;
            color: #4f46e5;
            background-color: #eef2ff;
            border-bottom: 1px solid #c7d2fe;
        }
        .travel-table tr:nth-child(even) {
            background-color: #f9fafb;
        }
        .join-code-display {
            font-family: 'Courier New', monospace;
            letter-spacing: 4px;
            font-size: 2rem;
        }
        .profile-btn-content {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .isochrone-badge {
            display: inline-block;
            background-color: #ec4899;
            color: white;
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div class="min-h-screen flex items-start justify-center p-4">
        <div class="container-card p-6 md:p-10 rounded-xl w-full">
            <h1 class="text-3xl font-bold text-gray-800 mb-2 text-center">Meetup Planner (Simulated Isochrone)</h1>
            <p class="text-gray-500 text-center mb-6">Find the spot with the **best travel accessibility** for all participants.</p>

            <div id="status-message" class="mt-4 p-3 bg-red-100 text-red-700 rounded-lg hidden" role="alert"></div>

            <div id="initial-loading" class="text-center py-10">
                <div class="loading-spinner mx-auto mb-3 border-indigo-500 border-t-indigo-500 w-8 h-8"></div>
                <p class="text-gray-500">Initializing services...</p>
            </div>

            <div id="view-profile" class="hidden space-y-4">
                <h2 class="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">Profile Setup Required</h2>
                <div class="p-4 bg-yellow-50 border-l-4 border-yellow-400 rounded-lg text-sm text-yellow-700">
                    <p class="font-medium">Welcome!</p>
                    <p>To join or create a group, please save your unique display name and primary home locality.</p>
                </div>
                <form id="profile-form" class="space-y-4">
                    <div>
                        <label for="profile-name" class="block text-sm font-medium text-gray-700 mb-1">Display Name</label>
                        <input type="text" id="profile-name" required class="w-full p-3 border border-gray-300 rounded-lg focus:ring-pink-500 focus:border-pink-500">
                    </div>
                    <div>
                        <label for="home-locality" class="block text-sm font-medium text-gray-700 mb-1">Primary Home Locality/Address</label>
                        <input type="text" id="home-locality" required placeholder="e.g., Jalahalli, Bangalore or East Village, NYC" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-pink-500 focus:border-pink-500">
                    </div>
                    <button type="submit" id="save-profile-btn" class="w-full text-white font-semibold py-3 rounded-xl bg-pink-500 hover:bg-pink-600 transition">
                        <span class="profile-btn-content">
                            <span id="profile-button-text">Save Profile & Continue</span>
                            <div id="profile-loading-indicator" class="loading-spinner hidden ml-3 border-white border-t-white"></div>
                        </span>
                    </button>
                </form>
            </div>

            <div id="view-main" class="hidden space-y-6">
                <div class="bg-indigo-50 p-3 rounded-lg flex justify-between items-center text-sm border border-indigo-200">
                    <p class="font-medium text-indigo-800 truncate">Logged in as <span id="user-display-name" class="font-bold"></span></p>
                    <button id="go-to-profile" class="text-xs text-indigo-600 hover:text-indigo-900 transition underline ml-4 flex-shrink-0">Edit Profile</button>
                </div>

                <div class="flex space-x-4">
                    <button id="show-create-btn" class="flex-1 py-2 font-medium rounded-lg transition-colors border-b-4 border-indigo-500 text-indigo-700 bg-indigo-100 shadow-md">Create Group</button>
                    <button id="show-join-btn" class="flex-1 py-2 font-medium rounded-lg transition-colors border-b-2 border-gray-300 text-gray-700 hover:bg-gray-100">Join Group</button>
                </div>

                <div id="view-create" class="space-y-4">
                    <h2 class="text-xl font-semibold text-gray-700 mb-2">Create New Group</h2>
                    <select id="occasion-create" required class="w-full p-3 border border-gray-300 rounded-lg bg-white focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out">
                        <option value="" disabled selected>Select an occasion</option>
                        <option value="Casual Hangout">Casual Hangout (Coffee, Parks)</option>
                        <option value="Birthday Celebration">Birthday Celebration (Dinner, Drinks)</option>
                        <option value="Outdoor Adventure">Outdoor Adventure (Hiking, Scenic Views)</option>
                        <option value="Cultural Visit">Cultural Visit (Museums, Historic Sites)</option>
                        <option value="Foodie Exploration">Foodie Exploration (Markets, Unique Restaurants)</option>
                        <option value="Team Building">Team Building (Escape Rooms, Activity Centers)</option>
                    </select>
                    <button type="button" id="create-group-btn" class="submit-button w-full text-white font-semibold py-3 rounded-xl">Create Group & Get Code</button>
                </div>

                <div id="view-join" class="hidden space-y-4">
                    <h2 class="text-xl font-semibold text-gray-700 mb-2">Join Existing Group</h2>
                    <div>
                        <label for="join-code-input" class="block text-sm font-medium text-gray-700 mb-1">Enter 6-Character Join Code</label>
                        <input type="text" id="join-code-input" maxlength="6" placeholder="ABC123" required class="w-full p-3 text-center text-xl tracking-wider uppercase border border-gray-300 rounded-lg focus:ring-pink-500 focus:border-pink-500">
                    </div>
                    <button type="button" id="join-by-code-btn" class="w-full text-white font-semibold py-3 rounded-xl bg-pink-500 hover:bg-pink-600 transition">Join Group</button>
                </div>

                <div id="view-session" class="hidden space-y-4 pt-4 border-t border-gray-200">
                    <h2 class="text-xl font-semibold text-gray-700 mb-2">Active Session <span id="session-occasion"></span></h2>

                    <div id="join-code-box" class="mt-2 p-4 bg-indigo-50 border-2 border-indigo-300 rounded-xl text-center">
                        <p class="text-sm font-medium text-indigo-700 mb-2">Share this Join Code</p>
                        <div class="flex justify-center items-center space-x-3">
                            <span id="session-join-code" class="join-code-display font-extrabold text-indigo-900 select-all"></span>
                            <button type="button" id="copy-code-btn" class="flex-shrink-0 px-3 py-1 bg-indigo-500 text-white text-sm font-medium rounded-lg hover:bg-indigo-600 transition duration-150 ease-in-out">Copy</button>
                        </div>
                    </div>

                    <h3 class="text-lg font-semibold text-gray-700 mt-6">Participants <span id="participant-count">0</span></h3>
                    <div id="participants-list" class="space-y-2 p-3 bg-white rounded-lg border border-gray-200">
                        <p class="text-gray-500 italic">Waiting for participants to join...</p>
                    </div>

                    <div class="flex flex-col space-y-3 mt-6">
                        <button type="button" id="calculate-btn" class="submit-button w-full text-white font-semibold py-3 rounded-xl flex items-center justify-center focus:outline-none focus:ring-4 focus:ring-indigo-500 focus:ring-opacity-50 disabled:opacity-50" disabled>
                            <span id="button-text">Find Optimal Meeting Spots (Isochrone)</span>
                            <div id="loading-indicator" class="loading-spinner hidden ml-3"></div>
                        </button>
                        <button type="button" id="end-session-btn" class="w-full text-sm font-semibold py-3 rounded-xl flex items-center justify-center bg-gray-200 text-gray-700 hover:bg-gray-300 transition duration-150 ease-in-out">End Session & Create New Group</button>
                    </div>
                </div>

                <div id="results-section" class="mt-8 pt-6 border-t border-gray-200 hidden">
                    <h2 class="text-2xl font-semibold text-gray-700 mb-4">Top Recommendations</h2>
                    <div id="recommendations-list" class="space-y-6"></div>
                    <div id="sources-container" class="mt-6 text-xs text-gray-500 border-t pt-4">
                        <p class="font-medium mb-2">Sources & Grounding (Based on **Simulated Isochrone Analysis**)</p>
                        <ul id="sources-list" class="space-y-1"></ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, setLogLevel, doc, getDoc, setDoc, addDoc, collection, onSnapshot, updateDoc, arrayUnion, query, where, getDocs } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';

        // CONFIGURATION SECTION
        const YOUR_FALLBACK_CONFIG = {
            apiKey: "AIzaSyBr2D6zEFX3u1wQTXE8aTgHFw5EeIUnsPE",
            authDomain: "html-9bee0.firebaseapp.com",
            projectId: "html-9bee0",
            storageBucket: "html-9bee0.firebasestorage.app",
            messagingSenderId: "893745664576",
            appId: "1893745664576web1e74ae24e1c9e9bba685a5",
            measurementId: "G-9DYC404SP0"
        };

        const firebaseConfig = typeof firebaseconfig !== 'undefined' ? JSON.parse(firebaseconfig) : YOUR_FALLBACK_CONFIG;
        const APP_ID = typeof appid !== 'undefined' ? appid : 'meetup-party-planner-v1';
        
        // GLOBAL STATE
        let db, auth, userId = 'anonymous', isAuthReady = false, userProfile = null;
        let currentGroupId = null, groupUnsubscribe = null;

        // DOM REFERENCES 
        const VIEWS = {
            loading: document.getElementById('initial-loading'),
            profile: document.getElementById('view-profile'),
            main: document.getElementById('view-main'),
            create: document.getElementById('view-create'),
            join: document.getElementById('view-join'),
            session: document.getElementById('view-session')
        };
        const PROFILE_FORM = document.getElementById('profile-form');
        const HOME_LOCALITY_INPUT = document.getElementById('home-locality');
        const PROFILE_NAME_INPUT = document.getElementById('profile-name');
        const SAVE_PROFILE_BTN = document.getElementById('save-profile-btn');
        const PROFILE_BUTTON_TEXT = document.getElementById('profile-button-text');
        const PROFILE_LOADING_INDICATOR = document.getElementById('profile-loading-indicator');
        const USER_DISPLAY_NAME = document.getElementById('user-display-name');
        const OCCASION_CREATE = document.getElementById('occasion-create');
        const CREATE_GROUP_BTN = document.getElementById('create-group-btn');
        const JOIN_BY_CODE_BTN = document.getElementById('join-by-code-btn');
        const JOIN_CODE_INPUT = document.getElementById('join-code-input');
        const CALCULATE_BTN = document.getElementById('calculate-btn');
        const SESSION_JOIN_CODE = document.getElementById('session-join-code');
        const COPY_CODE_BTN = document.getElementById('copy-code-btn');
        const PARTICIPANTS_LIST = document.getElementById('participants-list');
        const PARTICIPANT_COUNT = document.getElementById('participant-count');
        const SESSION_OCCASION = document.getElementById('session-occasion');
        const END_SESSION_BTN = document.getElementById('end-session-btn');
        const GO_TO_PROFILE_BTN = document.getElementById('go-to-profile');
        const RESULTS_SECTION = document.getElementById('results-section');
        const RECOMMENDATIONS_LIST = document.getElementById('recommendations-list');
        const SOURCES_LIST = document.getElementById('sources-list');
        const STATUS_MESSAGE = document.getElementById('status-message');
        const BUTTON_TEXT = document.getElementById('button-text');
        const LOADING_INDICATOR = document.getElementById('loading-indicator');
        const SHOW_CREATE_BTN = document.getElementById('show-create-btn');
        const SHOW_JOIN_BTN = document.getElementById('show-join-btn');


        // FIXED PATHS
        const PROFILE_COLLECTION_PATH = `artifacts/${APP_ID}/users`;
        const GROUP_COLLECTION_PATH = `artifacts/${APP_ID}/groups`;

        // FIREBASE INIT 
        setLogLevel('error');
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setupListeners();

                if (typeof initialauthtoken !== 'undefined') {
                    await signInWithCustomToken(auth, initialauthtoken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, async (user) => {
                    if (user) userId = user.uid;
                    else userId = crypto.randomUUID();
                    isAuthReady = true;
                    await loadUserProfile();
                });
            } catch (error) {
                console.error('Firebase Error:', error);
                showStatus(`Firebase failed: ${error.message}`, true);
                isAuthReady = true;
                setView('main', 'create');
            }
        });

        // --- Standard App Logic Functions (View, Profile, Group Management) ---

        function setView(viewName, subView = null) {
            Object.values(VIEWS).forEach(view => view.classList.add('hidden'));
            if (viewName === 'profile') VIEWS.profile.classList.remove('hidden');
            else if (viewName === 'main') {
                VIEWS.main.classList.remove('hidden');
                if (subView === 'create') {
                    VIEWS.create.classList.remove('hidden');
                    updateTabButtons('create');
                } else if (subView === 'join') {
                    VIEWS.join.classList.remove('hidden');
                    updateTabButtons('join');
                } else {
                    VIEWS.create.classList.remove('hidden');
                    updateTabButtons('create');
                }
            } else if (viewName === 'session') {
                VIEWS.main.classList.remove('hidden');
                VIEWS.session.classList.remove('hidden');
            } else {
                VIEWS.loading.classList.remove('hidden');
            }
        }

        function updateTabButtons(activeTab) {
            if (activeTab === 'create') {
                SHOW_CREATE_BTN.classList.replace('border-gray-300', 'border-indigo-500');
                SHOW_CREATE_BTN.classList.replace('text-gray-700', 'text-indigo-700');
                SHOW_CREATE_BTN.classList.remove('hover:bg-gray-100', 'border-b-2');
                SHOW_CREATE_BTN.classList.add('bg-indigo-100', 'shadow-md', 'border-b-4');
                SHOW_JOIN_BTN.classList.replace('border-indigo-500', 'border-gray-300');
                SHOW_JOIN_BTN.classList.replace('text-indigo-700', 'text-gray-700');
                SHOW_JOIN_BTN.classList.remove('bg-indigo-100', 'shadow-md', 'border-b-4');
                SHOW_JOIN_BTN.classList.add('hover:bg-gray-100', 'border-b-2');
            } else {
                SHOW_JOIN_BTN.classList.replace('border-gray-300', 'border-indigo-500');
                SHOW_JOIN_BTN.classList.replace('text-gray-700', 'text-indigo-700');
                SHOW_JOIN_BTN.classList.remove('hover:bg-gray-100', 'border-b-2');
                SHOW_JOIN_BTN.classList.add('bg-indigo-100', 'shadow-md', 'border-b-4');
                SHOW_CREATE_BTN.classList.replace('border-indigo-500', 'border-gray-300');
                SHOW_CREATE_BTN.classList.replace('text-indigo-700', 'text-gray-700');
                SHOW_CREATE_BTN.classList.remove('bg-indigo-100', 'shadow-md', 'border-b-4');
                SHOW_CREATE_BTN.classList.add('hover:bg-gray-100', 'border-b-2');
            }
        }

        async function loadUserProfile() {
            if (!db || !isAuthReady) return;
            try {
                const profileDocRef = doc(db, PROFILE_COLLECTION_PATH, userId);
                const docSnap = await getDoc(profileDocRef);
                if (docSnap.exists()) {
                    userProfile = docSnap.data();
                    userProfile.userId = userId;
                    PROFILE_NAME_INPUT.value = userProfile.name || '';
                    HOME_LOCALITY_INPUT.value = userProfile.locality || '';
                    USER_DISPLAY_NAME.textContent = userProfile.name || 'Friend';
                    setView('main', 'create');
                } else {
                    userProfile = null;
                    setView('profile');
                }
            } catch (error) {
                console.error('Profile load error:', error);
                setView('profile');
            }
        }

        async function saveProfile(e) {
            e.preventDefault();
            const name = PROFILE_NAME_INPUT.value.trim();
            const locality = HOME_LOCALITY_INPUT.value.trim();
            if (!name || !locality) {
                showStatus('Both fields required.', true);
                return;
            }
            if (!db) {
                showStatus('Database not ready.', true);
                return;
            }
            setLoading(true, SAVE_PROFILE_BTN);
            try {
                const profileDocRef = doc(db, PROFILE_COLLECTION_PATH, userId);
                const profileData = { name, locality, userId, updatedAt: new Date().toISOString() };
                await setDoc(profileDocRef, profileData, { merge: true });
                userProfile = profileData;
                USER_DISPLAY_NAME.textContent = userProfile.name;
                showStatus('Profile saved! Ready to plan.', false);
                setView('main', 'create');
            } catch (error) {
                console.error('Profile save error:', error);
                showStatus(`Save failed: ${error.message}`, true);
            } finally {
                setLoading(false, SAVE_PROFILE_BTN);
            }
        }

        function generateJoinCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < 6; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        async function isCodeUnique(code) {
            const q = query(collection(db, GROUP_COLLECTION_PATH), where('joinCode', '==', code));
            const querySnapshot = await getDocs(q);
            return querySnapshot.empty;
        }

        async function createGroupSession() {
            if (!userProfile || !db) {
                showStatus('Profile or database not ready.', true);
                return;
            }
            setLoading(true, CREATE_GROUP_BTN);
            const occasion = OCCASION_CREATE.value;
            if (!occasion) {
                showStatus('Select an occasion.', true);
                setLoading(false, CREATE_GROUP_BTN);
                return;
            }
            let joinCode, isUnique = false, attempts = 0;
            while (!isUnique && attempts < 5) {
                joinCode = generateJoinCode();
                isUnique = await isCodeUnique(joinCode);
                attempts++;
            }
            if (!isUnique) {
                showStatus('Failed to generate unique code.', true);
                setLoading(false, CREATE_GROUP_BTN);
                return;
            }
            const initialGroupData = {
                occasion, creatorId: userId, joinCode,
                participants: [{ userId: userProfile.userId, name: userProfile.name, locality: userProfile.locality }],
                createdAt: new Date().toISOString()
            };
            try {
                const docRef = await addDoc(collection(db, GROUP_COLLECTION_PATH), initialGroupData);
                currentGroupId = docRef.id;
                startGroupListener(currentGroupId);
                showStatus(`Group created! Code: ${joinCode}`, false);
            } catch (error) {
                console.error('Group creation error:', error);
                showStatus(`Group failed: ${error.message}`, true);
            } finally {
                setLoading(false, CREATE_GROUP_BTN);
            }
        }

        async function handleJoinByCode() {
            const code = JOIN_CODE_INPUT.value.trim().toUpperCase();
            if (!code || code.length !== 6 || !userProfile || !db) {
                showStatus('Invalid code or profile not ready.', true);
                return;
            }
            setLoading(true, JOIN_BY_CODE_BTN);
            try {
                const q = query(collection(db, GROUP_COLLECTION_PATH), where('joinCode', '==', code));
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    showStatus(`Group with code ${code} not found.`, true);
                    setLoading(false, JOIN_BY_CODE_BTN);
                    return;
                }

                const groupDoc = querySnapshot.docs[0];
                const groupId = groupDoc.id;
                const groupData = groupDoc.data();

                const isParticipant = groupData.participants.some(p => p.userId === userId);
                if (!isParticipant) {
                    const groupDocRef = doc(db, GROUP_COLLECTION_PATH, groupId);
                    await updateDoc(groupDocRef, {
                        participants: arrayUnion({
                            userId: userProfile.userId,
                            name: userProfile.name,
                            locality: userProfile.locality
                        })
                    });
                    showStatus(`${userProfile.name} joined the group!`, false);
                } else {
                    showStatus('Welcome back! Already in group.', false);
                }

                currentGroupId = groupId;
                startGroupListener(groupId);
                JOIN_CODE_INPUT.value = '';
            } catch (error) {
                console.error('Join error:', error);
                showStatus(`Join failed: ${error.message}`, true);
            } finally {
                setLoading(false, JOIN_BY_CODE_BTN);
            }
        }

        function startGroupListener(groupId) {
            if (groupUnsubscribe) groupUnsubscribe();
            if (!db) return;

            const groupDocRef = doc(db, GROUP_COLLECTION_PATH, groupId);
            groupUnsubscribe = onSnapshot(groupDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    renderGroupSession(docSnap.data());
                } else {
                    currentGroupId = null;
                    showStatus('Group session expired.', true);
                    setView('main', 'create');
                }
            }, (error) => {
                console.error('Listener error:', error);
                showStatus('Real-time updates failed.', true);
            });
        }

        function renderGroupSession(group) {
            RESULTS_SECTION.classList.add('hidden');
            const isCreator = group.creatorId === userId;
            SESSION_OCCASION.textContent = `(${group.occasion})`;
            PARTICIPANT_COUNT.textContent = group.participants.length;
            SESSION_JOIN_CODE.textContent = group.joinCode || 'N/A';

            PARTICIPANTS_LIST.innerHTML = '';
            if (group.participants?.length > 0) {
                group.participants.forEach(p => {
                    const isMe = p.userId === userId;
                    const isTheCreator = p.userId === group.creatorId;
                    const badgeClass = isMe ? 'bg-indigo-200 text-indigo-800' : 'bg-gray-100 text-gray-700';
                    const creatorText = isTheCreator ? ' - Creator' : '';
                    const listItem = `
                        <div class="flex justify-between items-center p-2 rounded-lg ${isMe ? 'border border-indigo-400 bg-indigo-50' : ''}">
                            <div class="font-medium text-gray-800">${p.name}</div>
                            <div class="flex items-center space-x-2">
                                <span class="text-xs ${badgeClass} px-2 py-0.5 rounded-full">${isMe ? 'You' : 'Friend'}${creatorText}</span>
                                <div class="text-sm text-gray-600 truncate max-w-[150px]">${p.locality}</div>
                            </div>
                        </div>`;
                    PARTICIPANTS_LIST.insertAdjacentHTML('beforeend', listItem);
                });
            } else {
                PARTICIPANTS_LIST.innerHTML = '<p class="text-gray-500 italic">Waiting for participants...</p>';
            }

            CALCULATE_BTN.disabled = group.participants.length < 2 || !isCreator;
            CALCULATE_BTN.title = group.participants.length < 2 ? 'Need 2+ participants to calculate' : (!isCreator ? 'Only the creator can start calculation' : 'Ready to calculate');
            setView('session');
        }

        // --- CORE GEOMETRY FUNCTIONS (Rigorous Math) ---

        // Converts degrees to radians
        function toRadian(degree) {
            return degree * Math.PI / 180;
        }

        // Converts radians to degrees
        function toDegree(radian) {
            return radian * 180 / Math.PI;
        }

        /**
         * Calculates the great-circle distance (Haversine Formula) between two coordinates in kilometers.
         * This function uses actual mathematics for distance calculation.
         * @param {number} lat1 
         * @param {number} lon1 
         * @param {number} lat2 
         * @param {number} lon2 
         * @returns {number} Distance in km.
         */
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // Earth radius in km
            const dLat = toRadian(lat2 - lat1);
            const dLon = toRadian(lon2 - lon1);
            
            // Haversine Formula Implementation
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(toRadian(lat1)) * Math.cos(toRadian(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; 
        }

        /**
         * Simulates a geocoder to generate distinct coordinates from locality text.
         * This ensures distinct non-zero distances.
         * @param {string} localityKey 
         * @returns {Object} {lat, lon}
         */
        function simulateCoordinates(localityKey) {
            const cleanKey = localityKey.trim().replace(/[^a-z0-9]/gi, '').toLowerCase();
            let sumChar = 0;
            for (let i = 0; i < cleanKey.length; i++) {
                sumChar += cleanKey.charCodeAt(i);
            }
            
            // Use large, randomized offsets (1 to 10 degrees, approx 111km to 1110km)
            const latOffset = (sumChar % 10) + 1.0 + (cleanKey.length * 0.1); 
            const lonOffset = (sumChar % 10) + 1.0 + (sumChar % 5) * 0.2; 
            
            // Base coordinates (Bengaluru, India - 12.97, 77.59)
            const baseLat = 12.9716;
            const baseLon = 77.5946;

            // Apply offsets, ensuring distinct quadrants
            const lat = baseLat + (sumChar % 2 === 0 ? latOffset : -latOffset);
            const lon = baseLon + (sumChar % 3 === 0 ? lonOffset : -lonOffset); 

            return { lat, lon };
        }

        /**
         * Simulates travel time based on straight-line Haversine distance.
         * @param {number} distanceKm - Haversine distance in kilometers.
         * @returns {number} Simulated travel time in minutes.
         */
        function simulateTravelTimeMinutes(distanceKm) {
            if (distanceKm < 50) {
                // Local driving speed
                return (distanceKm / 45) * 60 + 5; 
            } else if (distanceKm < 500) {
                // Regional travel speed
                return (distanceKm / 80) * 60;
            } else {
                // Major travel (long haul)
                return (distanceKm / 700) * 60 * 1.5; 
            }
        }

        /**
         * Performs a Simulated Isochrone Analysis to find the point that minimizes the maximum travel time.
         * This function uses an iterative search with the Haversine formula to find the mathematically optimal point.
         */
        function performSimulatedIsochroneAnalysis(participants) {
            const rawCoordinates = participants.map(p => {
                const coords = simulateCoordinates(p.locality);
                return { ...coords, locality: p.locality, name: p.name };
            });

            // 1. Calculate the initial geometric center (Centroid) as a starting point for the search grid.
            let avgLat = rawCoordinates.reduce((sum, p) => sum + p.lat, 0) / rawCoordinates.length;
            let avgLon = rawCoordinates.reduce((sum, p) => sum + p.lon, 0) / rawCoordinates.length;

            // 2. Define the search grid around the Centroid.
            const searchRange = 0.05; // +/- 5.5 km radius search area
            const steps = 10;
            const stepSize = (searchRange * 2) / steps;
            
            let bestLat = avgLat;
            let bestLon = avgLon;
            let minMaxTravelTime = Infinity;

            // 3. Iterate through the grid points.
            for (let i = -steps / 2; i <= steps / 2; i++) {
                for (let j = -steps / 2; j <= steps / 2; j++) {
                    const candidateLat = avgLat + i * stepSize;
                    const candidateLon = avgLon + j * stepSize;

                    let maxTime = 0;

                    // 4. Calculate maximum travel time (Max-Min approach for Isochrone)
                    for (const p of rawCoordinates) {
                        // **RIGOROUS MATH HERE:** haversineDistance is called for every point
                        const dist = haversineDistance(p.lat, p.lon, candidateLat, candidateLon);
                        const time = simulateTravelTimeMinutes(dist);
                        maxTime = Math.max(maxTime, time);
                    }

                    // 5. The optimal point minimizes the *maximum* travel time.
                    if (maxTime < minMaxTravelTime) {
                        minMaxTravelTime = maxTime;
                        bestLat = candidateLat;
                        bestLon = candidateLon;
                    }
                }
            }

            return {
                lat: bestLat,
                lon: bestLon,
                rawCoordinates: rawCoordinates,
                minMaxTravelTime: minMaxTravelTime // The key Isochrone result
            };
        }


        // --- MAIN CALCULATION FLOW ---

        async function handleFindOptimalSpots() {
            setLoading(true, CALCULATE_BTN);
            BUTTON_TEXT.textContent = 'Performing Isochrone Analysis...';

            if (!currentGroupId || !db) {
                showStatus('No active group.', true);
                setLoading(false, CALCULATE_BTN);
                return;
            }

            try {
                const groupDocSnap = await getDoc(doc(db, GROUP_COLLECTION_PATH, currentGroupId));
                const group = groupDocSnap.data();

                const participants = group.participants;
                const occasion = group.occasion;
                
                if (participants.length < 2 || !occasion) {
                    showStatus('Need 2+ participants & occasion.', true);
                    setLoading(false, CALCULATE_BTN);
                    return;
                }

                // 1. SIMULATED ISOCHRONE ANALYSIS (Uses rigorous Haversine internally)
                const result = performSimulatedIsochroneAnalysis(participants);
                const optimalLat = result.lat.toFixed(5);
                const optimalLon = result.lon.toFixed(5);
                const optimalString = `${optimalLat}, ${optimalLon}`;
                const minMaxTimeMinutes = result.minMaxTravelTime;

                BUTTON_TEXT.textContent = 'Generating Recommended Spots...';

                // 2. SIMULATE LOCAL RECOMMENDATIONS & TRAVEL DETAILS
                const recommendations = generateSimulatedRecommendations(
                    participants, 
                    occasion, 
                    optimalString, 
                    result.rawCoordinates,
                    minMaxTimeMinutes
                );

                displayResults(recommendations, []);
                showStatus(`Optimal spot calculated! Location: ${optimalString}`, false);

            } catch (error) {
                console.error('Calculation error:', error);
                showStatus(`Simulated Isochrone analysis failed: ${error.message}`, true);
                
                displayResults(generateFallbackRecommendations(
                    participants.map(p => p.locality), 
                    group.occasion, 
                    'Isochrone Analysis Error Fallback'
                ), []);
            } finally {
                setLoading(false, CALCULATE_BTN);
            }
        }


        // --- SIMULATION & FORMATTING FUNCTION ---

        function generateSimulatedRecommendations(participants, occasion, optimalString, rawCoordinates, minMaxTimeMinutes) {
            
            // Check if coordinates are close together (within 50km) to suggest local vs transit hubs
            const isLocal = rawCoordinates.every(c => haversineDistance(c.lat, c.lon, rawCoordinates[0].lat, rawCoordinates[0].lon) < 50); 
            
            // Suggest optimal points based on occasion selected
            const type = occasion.toLowerCase().includes('coffee') || occasion.toLowerCase().includes('hangout') ? 'Cafe' : 
                         occasion.toLowerCase().includes('dinner') || occasion.toLowerCase().includes('foodie') ? 'Restaurant' : 
                         'Park or Landmark';

            /**
             * Calculates the travel details (distance/time) from all participants to a destination.
             */
            const getTravelDetails = (destinationLat, destinationLon) => {
                return participants.map((p, index) => {
                    const startCoord = rawCoordinates[index];
                    
                    // **USES HAVERSINE DISTANCE**
                    const distance = haversineDistance(startCoord.lat, startCoord.lon, destinationLat, destinationLon);
                    const timeMinutes = simulateTravelTimeMinutes(distance);

                    // --- Distance Formatting ---
                    const distStr = distance < 1000 ? `${distance.toFixed(1)} km` : `${Math.floor(distance / 100) * 100} km`;
                    
                    // --- Time Formatting ---
                    let timeStr;
                    if (timeMinutes < 60) {
                        timeStr = `${Math.round(timeMinutes)} mins (Drive)`;
                    } else if (timeMinutes < 180) {
                        timeStr = `${(timeMinutes / 60).toFixed(1)} hrs (Drive/Rail)`;
                    } else {
                        timeStr = `${Math.floor(timeMinutes / 60)} hrs (Flight/Major Transit)`;
                    }
                    
                    return {
                        locality: p.locality,
                        distance: distStr,
                        travelTime: timeStr
                    };
                });
            };

            const optimalLat = parseFloat(optimalString.split(',')[0].trim());
            const optimalLon = parseFloat(optimalString.split(',')[1].trim());

            // Format the key Isochrone result
            let minMaxTimeString;
            if (minMaxTimeMinutes < 60) {
                minMaxTimeString = `${Math.round(minMaxTimeMinutes)} minutes`;
            } else {
                minMaxTimeString = `${(minMaxTimeMinutes / 60).toFixed(1)} hours`;
            }

            // Calculate the pure Centroid (Cartesian Mean) for the second suggestion
            // This is a complex geometric calculation often used for comparing center points
            let centroidX = 0, centroidY = 0, centroidZ = 0;
            rawCoordinates.forEach(p => {
                const latRad = toRadian(p.lat);
                const lonRad = toRadian(p.lon);
                centroidX += Math.cos(latRad) * Math.cos(lonRad);
                centroidY += Math.cos(latRad) * Math.sin(lonRad);
                centroidZ += Math.sin(latRad);
            });
            const total = rawCoordinates.length;
            const centroidLonRad = Math.atan2(centroidY / total, centroidX / total);
            const hyp = Math.sqrt(Math.pow(centroidX / total, 2) + Math.pow(centroidY / total, 2));
            const centroidLatRad = Math.atan2(centroidZ / total, hyp);
            const centroidLat = toDegree(centroidLatRad);
            const centroidLon = toDegree(centroidLonRad);


            return [
                {
                    rank: 1,
                    placeName: isLocal ? `Central ${type} with Best Access` : 'Major Transit Hub (Optimal Access)',
                    exactAddress: `Optimal Isochrone Point: ${optimalString}`,
                    justification: `This spot minimizes the **longest journey** any single participant has to make (Max Travel Time: **${minMaxTimeString}**). This is the Isochrone result for best accessibility.`,
                    travelDetails: getTravelDetails(optimalLat, optimalLon)
                },
                {
                    rank: 2,
                    placeName: isLocal ? `Recommended ${type} Near Center` : 'Geometric Center Conference Hotel',
                    exactAddress: `Lat: ${centroidLat.toFixed(5)}, Lon: ${centroidLon.toFixed(5)}`,
                    justification: `The pure **geometric center** (Cartesian mean) - this point minimizes the *sum* of distances, often slightly off the Isochrone point, but useful for comparing the ideal geographic center.`,
                    travelDetails: getTravelDetails(centroidLat, centroidLon)
                },
                {
                    rank: 3,
                    placeName: isLocal ? `The ${type} Landmark` : 'Major Airport / High-Speed Rail Terminal',
                    // Offset the Isochrone point by a fixed distance towards one of the participants (Simulated amenity)
                    exactAddress: `Lat: ${(optimalLat + 0.005).toFixed(5)}, Lon: ${(optimalLon - 0.002).toFixed(5)}`,
                    justification: `A recognizable landmark, slightly offset from the absolute best point, but often offering better facilities or recognizable arrival/departure options.`,
                    travelDetails: getTravelDetails(optimalLat + 0.005, optimalLon - 0.002)
                }
            ];
        }
        
        // üü° FALLBACK FOR CATASTROPHIC FAILURES 
        function generateFallbackRecommendations(localities, occasion, centroid) {
            const place = occasion.toLowerCase().includes('food') ? 'Gourmet Food Market' : 'Public Library';
            
            const travelDetails = () => {
                return localities.map(loc => {
                    return { 
                        locality: loc, 
                        distance: `5.0 km`, 
                        travelTime: `15-25 mins (Drive)` 
                    };
                });
            };

            return [
                {
                    rank: 1,
                    placeName: `Generic Central ${place}`,
                    exactAddress: `Fallback Center Point (Approx ${centroid})`,
                    justification: `The primary calculation failed, using generic central meeting point recommendations based on the group's occasion.`,
                    travelDetails: travelDetails()
                }
            ];
        }


        // RESULT DISPLAY, EVENT LISTENERS, UTILITIES 

        function displayResults(recommendations, sources) {
            RECOMMENDATIONS_LIST.innerHTML = '';
            recommendations.forEach(place => {
                const travelRows = place.travelDetails.map(d => 
                    `<tr><td class="text-gray-600 truncate max-w-[120px]">${d.locality}</td><td class="font-medium">${d.distance}</td><td class="font-medium text-indigo-700">${d.travelTime}</td></tr>`
                ).join('');
                
                const card = `
                    <div class="bg-white p-6 rounded-xl shadow-2xl border-l-4 border-indigo-500">
                        <div class="flex items-start space-x-4 mb-4">
                            <span class="text-3xl font-bold text-indigo-600">${place.rank}</span>
                            <div>
                                <h3 class="text-xl font-bold">${place.placeName}</h3>
                                <p class="text-sm text-gray-500 mt-1">üìç ${place.exactAddress}</p>
                            </div>
                        </div>
                        <p class="text-sm text-gray-700 italic border-l-2 pl-3 mb-4">${place.justification}</p>
                        <h4 class="text-md font-semibold mb-2">Travel from each location:</h4>
                        <div class="overflow-x-auto rounded-lg border">
                            <table class="travel-table w-full text-sm">
                                <thead><tr><th>From</th><th>Distance</th><th>Time</th></tr></thead>
                                <tbody>${travelRows}</tbody>
                            </table>
                        </div>
                    </div>`;
                RECOMMENDATIONS_LIST.insertAdjacentHTML('beforeend', card);
            });

            SOURCES_LIST.innerHTML = '';
            RESULTS_SECTION.classList.remove('hidden');
        }

        function setupListeners() {
            PROFILE_FORM.addEventListener('submit', saveProfile);
            CREATE_GROUP_BTN.addEventListener('click', createGroupSession);
            JOIN_BY_CODE_BTN.addEventListener('click', handleJoinByCode);
            CALCULATE_BTN.addEventListener('click', handleFindOptimalSpots);
            COPY_CODE_BTN.addEventListener('click', () => copyToClipboard(SESSION_JOIN_CODE.textContent, 'Join Code'));
            END_SESSION_BTN.addEventListener('click', () => {
                if (groupUnsubscribe) groupUnsubscribe();
                currentGroupId = null;
                setView('main', 'create');
                showStatus('Session ended.', false);
            });
            GO_TO_PROFILE_BTN.addEventListener('click', () => setView('profile'));
            SHOW_CREATE_BTN.addEventListener('click', () => setView('main', 'create'));
            SHOW_JOIN_BTN.addEventListener('click', () => setView('main', 'join'));
        }

        function copyToClipboard(text, item) {
            if (!text) return;
            try {
                navigator.clipboard.writeText(text).then(() => {
                    showStatus(`${item} copied!`, false);
                });
            } catch {
                const temp = document.createElement('textarea');
                temp.value = text;
                document.body.appendChild(temp);
                temp.select();
                document.execCommand('copy');
                document.body.removeChild(temp);
                showStatus(`${item} copied!`, false);
            }
        }

        function showStatus(message, isError = false) {
            STATUS_MESSAGE.textContent = message;
            STATUS_MESSAGE.className = `mt-4 p-3 rounded-lg ${isError ? 'bg-red-100 text-red-700 border-red-400 border' : 'bg-green-100 text-green-700 border-green-400 border'}`;
            STATUS_MESSAGE.classList.remove('hidden');
        }

        function setLoading(isLoading, buttonRef) {
            buttonRef.disabled = isLoading;
            let textElement, indicatorElement;
            if (buttonRef === CALCULATE_BTN) {
                textElement = BUTTON_TEXT;
                indicatorElement = LOADING_INDICATOR;
                if (!isLoading) textElement.textContent = 'Find Optimal Meeting Spots (Isochrone)';
            } else if (buttonRef === SAVE_PROFILE_BTN) {
                textElement = PROFILE_BUTTON_TEXT;
                indicatorElement = PROFILE_LOADING_INDICATOR;
                textElement.textContent = isLoading ? 'Saving...' : 'Save Profile & Continue';
            } else if (buttonRef === CREATE_GROUP_BTN) {
                buttonRef.textContent = isLoading ? 'Creating...' : 'Create Group & Get Code';
            } else if (buttonRef === JOIN_BY_CODE_BTN) {
                buttonRef.textContent = isLoading ? 'Joining...' : 'Join Group';
            }

            if (indicatorElement) indicatorElement.classList.toggle('hidden', !isLoading);
        }
    </script>
</body>
</html>
