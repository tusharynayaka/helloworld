                showStatus('Calculation complete! Results displayed.', false);
            } catch (error) {
                console.error("Calculation failed:", error);
                showStatus(`Calculation failed: ${error.message}`, true);
            } finally {
                setButtonLoading(false);
            }
        }
        
        // --- Display Functions ---

        function displayResults(results, validParticipants) {
            RECOMMENDATIONS_LIST.innerHTML = '';
            
            if (results.length === 0) {
                RECOMMENDATIONS_LIST.innerHTML = '<p class="text-gray-500 italic">No valid meetup locations could be calculated. Please check your addresses or API quota.</p>';
                RESULTS_SECTION.classList.remove('hidden');
                return;
            }
            
            // Check if L (Leaflet) is defined before trying to initialize the map
            if (typeof L === 'undefined') {
                RECOMMENDATIONS_LIST.innerHTML = '<p class="text-red-500 font-bold">Error: Map library (Leaflet) failed to load. Cannot display map or markers.</p>';
                RESULTS_SECTION.classList.remove('hidden');
                return;
            }

            // Initialize Map
            const initialCenter = results[0];
            initMap(initialCenter.lat, initialCenter.lon);

            // Track map bounds (Include all locations and participants for accurate zoom)
            const bounds = L.latLngBounds([]);

            // 1. Add participant markers and update bounds
            validParticipants.forEach(p => {
                addMarker(p.lat, p.lon, `**${p.displayName}** (Origin: ${p.homeLocality})`, 'origin');
                bounds.extend([p.lat, p.lon]);
            });
            
            results.forEach((location, index) => {
                location.rank = index + 1;
                
                // 2. Add Location Marker and update bounds
                const markerType = location.isCentroid ? 'center' : 'landmark';
                addMarker(location.lat, location.lon, `**#${index + 1} ${location.placeName}**<br>Total Distance: ${formatDistance(location.totalDistance, location.allRouted)}`, markerType);
                bounds.extend([location.lat, location.lon]);


                let detailsHtml = location.travelDetails.map(d => `
                    <tr>
                        <td class="px-2 py-1 text-sm text-gray-700 font-medium">${d.displayName}</td>
                        <td class="px-2 py-1 text-sm ${d.isRouted ? 'text-gray-600' : 'text-red-600 font-semibold'}">${formatDistance(d.distance, d.isRouted)}</td>
                        <td class="px-2 py-1 text-sm ${d.isRouted ? 'text-gray-600' : 'text-red-600 font-semibold'}">${d.isRouted ? formatTime(d.duration) : 'No Route Found'}</td>
                    </tr>
                `).join('');
                
                const centroidNote = location.isCentroid ? '<p class="text-sm italic text-indigo-600 mb-2">This is the **Mathematical Center**. Landmark suggestions follow.</p>' : '';
                const routingWarning = location.allRouted ? '' : '<p class="text-xs font-semibold text-red-600 mt-2">⚠️ Note: Some distances are straight-line (Haversine) as a precise driving route could not be found for all origins. This location is still ranked highly based on its geometric distance.</p>';

                const cardHtml = `
                    <div class="p-5 border-2 rounded-xl transition-shadow ${index === 0 ? 'bg-green-50 border-green-300 shadow-lg' : 'bg-white border-gray-200 shadow-md hover:shadow-lg'}">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="text-xl font-bold ${index === 0 ? 'text-green-700' : 'text-indigo-700'}">
                                ${index + 1}. ${location.placeName}
                                ${index === 0 ? '<span class="isochrone-badge bg-green-500">BEST ACCESS</span>' : ''}
                            </h3>
                        </div>
                        ${centroidNote}
                        <p class="text-gray-600 mb-2 text-sm italic">Lat: ${location.lat.toFixed(5)}, Lon: ${location.lon.toFixed(5)}</p>
                        <p class="text-gray-600 mb-4 text-sm font-medium">Worst-case travel time (Routed): **${location.maxDuration !== 0 ? formatTime(location.maxDuration) : 'N/A (No Valid Routed Times)'}**.</p>
                    
                        <div class="overflow-x-auto">
                            <table class="min-w-full travel-table rounded-lg">
                                <thead>
                                    <tr>
                                        <th class="rounded-tl-lg">Participant</th>
                                        <th>Distance</th>
                                        <th class="rounded-tr-lg">Time (Driving)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${detailsHtml}
                                </tbody>
                            </table>
                            ${routingWarning}
                        </div>
                    </div>
                `;
                RECOMMENDATIONS_LIST.innerHTML += cardHtml;
            });
            
            // 3. Fit Map to Bounds
            if (bounds.isValid()) {
                map.fitBounds(bounds, { padding: [50, 50] });
            } else {
                 // Fallback if only one or no points are valid
                map.setView([initialCenter.lat, initialCenter.lon], 10);
            }

            RESULTS_SECTION.classList.remove('hidden');
            // Force map redraw after section becomes visible
            setTimeout(() => map.invalidateSize(), 300); 
            document.getElementById('sources-container').innerHTML = `
                <p class="font-medium mb-2">Data Source: **Latlong.ai API Hub** (Geocoding, Distance Matrix, Landmark APIs)</p>
            `;
        }

        // =========================================================================
        // FIREBASE/AUTH/GROUP LISTENERS (State Management) - Omitted for brevity (unchanged)
        // =========================================================================
        
        async function loadUserProfile() {
            const userDocRef = doc(db, PROFILE_COLLECTION_PATH, userId);
            const docSnap = await getDoc(userDocRef);

            if (docSnap.exists()) {
                userProfile = docSnap.data();
                USER_DISPLAY_NAME.textContent = userProfile.displayName;
                setView('main', userProfile.currentGroupId ? 'session' : 'create');
                if (userProfile.currentGroupId) {
                    currentGroupId = userProfile.currentGroupId;
                    setupGroupListener(currentGroupId);
                }
            } else {
                setView('profile');
            }
        }

        async function saveProfile(event) {
            event.preventDefault();
            setButtonLoading(true, SAVE_PROFILE_BTN);

            const displayName = PROFILE_NAME_INPUT.value.trim();
            const homeLocality = HOME_LOCALITY_INPUT.value.trim();

            if (!displayName || !homeLocality) {
                showStatus('Display Name and Home Locality (Pin Code + City) are required.', true);
                setButtonLoading(false, SAVE_PROFILE_BTN);
                return;
            }

            try {
                showStatus('Verifying Pin Code and Locality via Latlong.ai Geocoding...', false);
                const coords = await geocodeAddress(homeLocality);

                if (!coords) {
                    throw new Error("Could not find precise coordinates for the provided Pin Code/Address. Please ensure you entered the Pin Code followed by the City/Locality (e.g., 560013, Bengaluru).");
                }

                userProfile = {
                    displayName: displayName,
                    homeLocality: homeLocality,
                    lat: coords.lat,
                    lon: coords.lon,
                    currentGroupId: userProfile ? userProfile.currentGroupId : null
                };

                const userDocRef = doc(db, PROFILE_COLLECTION_PATH, userId);
                await setDoc(userDocRef, userProfile, { merge: true });

                showStatus('Profile saved successfully! Coordinates received.', false);
                USER_DISPLAY_NAME.textContent = userProfile.displayName;
                setView('main', userProfile.currentGroupId ? 'session' : 'create');
            } catch (error) {
                console.error("Error saving profile:", error);
                const displayMessage = error.message.includes("coordinates") ? 
                    error.message : 
                    `Error saving profile: ${error.message}`;
                    
                showStatus(displayMessage, true);
            } finally {
                setButtonLoading(false, SAVE_PROFILE_BTN);
            }
        }


        async function createGroup() {
            setButtonLoading(true, CREATE_GROUP_BTN);
            try {
                const occasion = OCCASION_CREATE.value;
                if (!occasion) {
                    showStatus('Please select an occasion.', true);
                    setButtonLoading(false, CREATE_GROUP_BTN);
                    return;
                }

                const newCode = generateGroupCode();
                const newGroupRef = await addDoc(collection(db, GROUP_COLLECTION_PATH), {
                    code: newCode,
                    occasion: occasion,
                    participants: [{
                        userId: userId,
                        displayName: userProfile.displayName,
                        homeLocality: userProfile.homeLocality,
                        lat: userProfile.lat,
                        lon: userProfile.lon
                    }],
                    createdAt: new Date().toISOString()
                });

                currentGroupId = newGroupRef.id;
                userProfile.currentGroupId = currentGroupId;
                await setDoc(doc(db, PROFILE_COLLECTION_PATH, userId), { currentGroupId: currentGroupId }, { merge: true });

                setupGroupListener(currentGroupId);
                setView('main', 'session');
                showStatus(`Group created! Code: ${newCode}`, false);

            } catch (error) {
                console.error("Error creating group:", error);
                showStatus(`Error creating group: ${error.message}`, true);
            } finally {
                setButtonLoading(false, CREATE_GROUP_BTN);
            }
        }

        async function joinGroupByCode() {
            setButtonLoading(true, JOIN_BY_CODE_BTN);
            const code = JOIN_CODE_INPUT.value.trim().toUpperCase();

            try {
                const q = query(collection(db, GROUP_COLLECTION_PATH), where("code", "==", code));
                const querySnapshot = await getDocs(q);

                if (querySnapshot.empty) {
                    showStatus('Error: Invalid or expired group code.', true);
                    return;
                }

                const groupDoc = querySnapshot.docs[0];
                const groupId = groupDoc.id;
                const groupData = groupDoc.data();

                // Check if already a participant
                const isParticipant = groupData.participants.some(p => p.userId === userId);
                if (!isParticipant) {
                    const participantData = {
                        userId: userId,
                        displayName: userProfile.displayName,
                        homeLocality: userProfile.homeLocality,
                        lat: userProfile.lat,
                        lon: userProfile.lon
                    };
                    
                    const groupDocRef = doc(db, GROUP_COLLECTION_PATH, groupId);
                    await updateDoc(groupDocRef, {
                        participants: arrayUnion(participantData)
                    });
                }

                currentGroupId = groupId;
                userProfile.currentGroupId = currentGroupId;
                await setDoc(doc(db, PROFILE_COLLECTION_PATH, userId), { currentGroupId: currentGroupId }, { merge: true });

                setupGroupListener(currentGroupId);
                setView('main', 'session');
                showStatus(`Successfully joined group: ${code}`, false);

            } catch (error) {
                console.error("Error joining group:", error);
                showStatus(`Error joining group: ${error.message}`, true);
            } finally {
                setButtonLoading(false, JOIN_BY_CODE_BTN);
            }
        }

        function setupGroupListener(groupId) {
            if (groupUnsubscribe) groupUnsubscribe(); 
            const groupDocRef = doc(db, GROUP_COLLECTION_PATH, groupId);
            groupUnsubscribe = onSnapshot(groupDocRef, handleGroupSnapshot, (error) => {
                console.error("Group listener error:", error);
                showStatus("Group session connection lost.", true);
            });
        }

        function handleGroupSnapshot(docSnapshot) {
            if (!docSnapshot.exists()) {
                currentGroupId = null;
                userProfile.currentGroupId = null;
                setDoc(doc(db, PROFILE_COLLECTION_PATH, userId), { currentGroupId: null }, { merge: true });
                setView('main', 'create');
                showStatus('The session you were in has ended.', true);
                CALCULATE_BTN.disabled = true;
                return;
            }

            const groupData = docSnapshot.data();
            const participants = groupData.participants || [];

            SESSION_JOIN_CODE.textContent = groupData.code;
            PARTICIPANT_COUNT.textContent = participants.length;
            SESSION_OCCASION.textContent = `(${groupData.occasion})`;

            PARTICIPANTS_LIST.innerHTML = participants.map(p => {
                const isCurrent = p.userId === userId;
                const badge = isCurrent ? `<span class="bg-indigo-200 text-indigo-800 text-xs font-semibold px-2 py-0.5 rounded ml-2">You</span>` : '';
                const coordsDisplay = p.lat && p.lon ? `[${p.lat.toFixed(4)}, ${p.lon.toFixed(4)}]` : `<span class="text-red-500 font-bold">ADDRESS FAILED</span>`;
                
                return `
                    <div class="text-sm ${isCurrent ? 'font-bold text-indigo-700' : 'text-gray-700'} border-b border-gray-100 p-1 last:border-b-0">
                        ${p.displayName}${badge}
                        <span class="text-xs text-gray-500 italic block mt-0.5">
                            Pin Code: ${p.homeLocality}
                            <span class="ml-2">Coords: ${coordsDisplay}</span>
                        </span>
                    </div>
                `;
            }).join('');

            CALCULATE_BTN.disabled = participants.length < 2;
        }

        async function endSession() {
            if (!currentGroupId) return;

            const groupDocRef = doc(db, GROUP_COLLECTION_PATH, currentGroupId);
            try {
                await deleteDoc(groupDocRef); // Use deleteDoc to remove the group
            } catch (error) {
                console.error("Error deleting group:", error);
            }
            
            if (groupUnsubscribe) groupUnsubscribe();
            currentGroupId = null;
            userProfile.currentGroupId = null;
            await setDoc(doc(db, PROFILE_COLLECTION_PATH, userId), { currentGroupId: null }, { merge: true });

            setView('main', 'create');
            showStatus('Session successfully ended.', false);
            RESULTS_SECTION.classList.add('hidden');
        }


        // --- Event Listeners Setup ---
        function setupListeners() {
            PROFILE_FORM.addEventListener('submit', saveProfile);
            GO_TO_PROFILE_BTN.addEventListener('click', () => setView('profile'));
            
            SHOW_CREATE_BTN.addEventListener('click', () => setView('main', 'create'));
            SHOW_JOIN_BTN.addEventListener('click', () => setView('main', 'join'));

            CREATE_GROUP_BTN.addEventListener('click', createGroup);
            JOIN_BY_CODE_BTN.addEventListener('click', joinGroupByCode);
            END_SESSION_BTN.addEventListener('click', endSession);
            COPY_CODE_BTN.addEventListener('click', () => copyToClipboard(SESSION_JOIN_CODE.textContent));
            
            CALCULATE_BTN.addEventListener('click', findOptimalMeetupLocation);
        }

        // =========================================================================
        // FIREBASE INIT
        // =========================================================================

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Initialize Leaflet functions only after DOM is ready
                setupListeners();

                // Start anonymous authentication immediately
                await signInAnonymously(auth);
                
                // Set up the listener for auth state changes
                onAuthStateChanged(auth, async (user) => {
                    if (user) userId = user.uid;
                    else userId = crypto.randomUUID();
                    isAuthReady = true;
                    // Once authenticated, load the user's profile
                    await loadUserProfile();
                });
            } catch (error) {
                console.error('Firebase Initialization Error:', error);
                showStatus(`Firebase failed: ${error.message}. Group features may not work.`, true);
                isAuthReady = true;
                // Fallback view if Firebase fails to load
                setView('profile');
            }
        });

    </script>
</body>
</html>
